<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Robot WebRTC Video Test</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background: #1a1a1a;
            color: #fff;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1200px;
            width: 100%;
            text-align: center;
        }
        
        h1 {
            color: #4CAF50;
            margin-bottom: 30px;
        }
        
        .video-container {
            background: #333;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        
        #videoElement {
            width: 100%;
            max-width: 800px;
            height: auto;
            border-radius: 8px;
            background: #000;
        }
        
        .controls {
            margin: 20px 0;
        }
        
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 12px 24px;
            margin: 0 10px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            transition: background 0.3s;
        }
        
        button:hover {
            background: #45a049;
        }
        
        button:disabled {
            background: #666;
            cursor: not-allowed;
        }
        
        .status {
            background: #2d2d2d;
            border-radius: 8px;
            padding: 15px;
            margin: 20px 0;
            text-align: left;
            max-height: 300px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 14px;
        }
        
        .status-connected {
            color: #4CAF50;
        }
        
        .status-error {
            color: #f44336;
        }
        
        .status-info {
            color: #2196F3;
        }
        
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        
        .stat-item {
            background: #333;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #4CAF50;
        }
        
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #4CAF50;
        }
        
        .stat-label {
            font-size: 14px;
            color: #ccc;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ü§ñ Robot WebRTC Video Test</h1>
        <p style="color: #4CAF50; font-size: 18px; margin-bottom: 20px;">
            üì° –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ —Ä–æ–±–æ—Ç—É: <strong>193.169.240.11:8080</strong>
        </p>
        
        <div class="controls">
            <button id="connectBtn" onclick="startConnection()">üîå –ü–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è –∫ —Ä–æ–±–æ—Ç—É</button>
            <button id="disconnectBtn" onclick="stopConnection()" disabled>üîå –û—Ç–∫–ª—é—á–∏—Ç—å—Å—è</button>
        </div>
        
        <div class="stats">
            <div class="stat-item">
                <div class="stat-value" id="connectionStatus">‚ùå</div>
                <div class="stat-label">–°—Ç–∞—Ç—É—Å –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="iceStatus">‚ùå</div>
                <div class="stat-label">ICE —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="videoStatus">‚ùå</div>
                <div class="stat-label">–í–∏–¥–µ–æ –ø–æ—Ç–æ–∫</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="framesCount">0</div>
                <div class="stat-label">–ö–∞–¥—Ä–æ–≤ –ø–æ–ª—É—á–µ–Ω–æ</div>
            </div>
        </div>
        
        <div class="video-container">
            <video id="videoElement" autoplay muted playsinline>
                <p>–í–∞—à –±—Ä–∞—É–∑–µ—Ä –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –≤–∏–¥–µ–æ —ç–ª–µ–º–µ–Ω—Ç.</p>
            </video>
        </div>
        
        <div class="status" id="statusLog">
            <div class="status-info">üìã –õ–æ–≥ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è:</div>
        </div>
    </div>

    <script>
        let ws = null;
        let pc = null;
        let localVideo = null;
        let statsInterval = null;
        let frameCount = 0;
        let registrationTimeout = null;

        const statusLog = document.getElementById('statusLog');
        const videoElement = document.getElementById('videoElement');
        const connectBtn = document.getElementById('connectBtn');
        const disconnectBtn = document.getElementById('disconnectBtn');

        // WebRTC configuration
        const rtcConfig = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' }
            ]
        };

        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const className = `status-${type}`;
            const logEntry = `<div class="${className}">[${timestamp}] ${message}</div>`;
            statusLog.innerHTML += logEntry;
            statusLog.scrollTop = statusLog.scrollHeight;
            console.log(`[${timestamp}] ${message}`);
        }

        function updateStatus(element, value, isConnected = false) {
            const statusElement = document.getElementById(element);
            statusElement.textContent = value;
            statusElement.parentElement.style.borderLeftColor = isConnected ? '#4CAF50' : '#f44336';
        }

        async function startConnection() {
            try {
                log('üöÄ –ù–∞—á–∏–Ω–∞–µ–º –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ —Ä–æ–±–æ—Ç—É...');
                connectBtn.disabled = true;
                
                // Create WebSocket connection
                const wsUrl = `ws://193.169.240.11:8080`;
                ws = new WebSocket(wsUrl);
                
                ws.onopen = () => {
                    log('‚úÖ WebSocket –ø–æ–¥–∫–ª—é—á–µ–Ω', 'connected');
                    updateStatus('connectionStatus', 'üîó WebSocket', true);
                    
                    // –†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º—Å—è –∫–∞–∫ –∫–ª–∏–µ–Ω—Ç —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è
                    log('üìù –†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º—Å—è –∫–∞–∫ –∫–ª–∏–µ–Ω—Ç —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è...');
                    ws.send('REGISTER!CONTROLLER');
                    
                    // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ç–∞–π–º–∞—É—Ç —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏
                    registrationTimeout = setTimeout(() => {
                        if (ws && ws.readyState === WebSocket.OPEN) {
                            log('‚ùå –¢–∞–π–º–∞—É—Ç —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ - —Å–µ—Ä–≤–µ—Ä –Ω–µ –æ—Ç–≤–µ—Ç–∏–ª', 'error');
                            updateStatus('connectionStatus', '‚ùå –¢–∞–π–º–∞—É—Ç —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏');
                        }
                    }, 5000);
                };
                
                ws.onmessage = async (event) => {
                    const message = event.data;
                    log(`üì• –ü–æ–ª—É—á–µ–Ω–æ —Å–æ–æ–±—â–µ–Ω–∏–µ: ${message}`);
                    
                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —ç—Ç–æ –æ—Ç–≤–µ—Ç –Ω–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—é –∏–ª–∏ JSON
                    if (message === 'REGISTERED!CONTROLLER') {
                        // –û—Ç–º–µ–Ω—è–µ–º —Ç–∞–π–º–∞—É—Ç —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏
                        if (registrationTimeout) {
                            clearTimeout(registrationTimeout);
                            registrationTimeout = null;
                        }
                        
                        log('‚úÖ –£—Å–ø–µ—à–Ω–æ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω—ã –∫–∞–∫ –∫–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä', 'connected');
                        updateStatus('connectionStatus', 'üéÆ –ö–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä', true);
                        initWebRTC();
                    } else if (message.startsWith('{')) {
                        // JSON —Å–æ–æ–±—â–µ–Ω–∏–µ
                        try {
                            const data = JSON.parse(message);
                            await handleWebSocketMessage(data);
                        } catch (e) {
                            log(`‚ùå –û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ JSON: ${e.message}`, 'error');
                        }
                    } else {
                        // –î—Ä—É–≥–∏–µ —Ç–µ–∫—Å—Ç–æ–≤—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è
                        log(`üìÑ –¢–µ–∫—Å—Ç–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ: ${message}`);
                    }
                };
                
                ws.onerror = (error) => {
                    log(`‚ùå –û—à–∏–±–∫–∞ WebSocket: ${error}`, 'error');
                    updateStatus('connectionStatus', '‚ùå –û—à–∏–±–∫–∞');
                };
                
                ws.onclose = () => {
                    log('üîå WebSocket –æ—Ç–∫–ª—é—á–µ–Ω');
                    updateStatus('connectionStatus', '‚ùå –û—Ç–∫–ª—é—á–µ–Ω');
                    connectBtn.disabled = false;
                    disconnectBtn.disabled = true;
                };
                
            } catch (error) {
                log(`‚ùå –û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è: ${error.message}`, 'error');
                connectBtn.disabled = false;
            }
        }

        async function initWebRTC() {
            try {
                log('üé¨ –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è WebRTC...');
                
                // Create peer connection
                pc = new RTCPeerConnection(rtcConfig);
                
                // Handle ICE candidates
                pc.onicecandidate = (event) => {
                    if (event.candidate) {
                        log('üßä –û—Ç–ø—Ä–∞–≤–ª—è–µ–º ICE candidate');
                        ws.send(JSON.stringify({
                            type: 'webrtc-signal',
                            signalType: 'ice-candidate',
                            data: {
                                candidate: event.candidate.candidate,
                                sdpMLineIndex: event.candidate.sdpMLineIndex,
                                sdpMid: event.candidate.sdpMid
                            }
                        }));
                    }
                };
                
                // Handle connection state changes
                pc.onconnectionstatechange = () => {
                    log(`üîó –°–æ—Å—Ç–æ—è–Ω–∏–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è: ${pc.connectionState}`);
                    updateStatus('connectionStatus', `üîó ${pc.connectionState}`, 
                        pc.connectionState === 'connected');
                };
                
                pc.oniceconnectionstatechange = () => {
                    log(`üßä ICE —Å–æ—Å—Ç–æ—è–Ω–∏–µ: ${pc.iceConnectionState}`);
                    updateStatus('iceStatus', `üßä ${pc.iceConnectionState}`, 
                        pc.iceConnectionState === 'connected');
                };
                
                // Handle incoming video stream
                pc.ontrack = (event) => {
                    log('üé• –ü–æ–ª—É—á–µ–Ω –≤–∏–¥–µ–æ –ø–æ—Ç–æ–∫!', 'connected');
                    updateStatus('videoStatus', 'üé• –ê–∫—Ç–∏–≤–µ–Ω', true);
                    
                    if (event.streams && event.streams[0]) {
                        videoElement.srcObject = event.streams[0];
                        startVideoStats();
                    }
                };
                
                // Request video from robot
                log('üìû –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∑–∞–ø—Ä–æ—Å –Ω–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ...');
                ws.send(JSON.stringify({
                    type: 'webrtc-signal',
                    signalType: 'request_video',
                    data: {}
                }));
                
                disconnectBtn.disabled = false;
                
            } catch (error) {
                log(`‚ùå –û—à–∏–±–∫–∞ WebRTC: ${error.message}`, 'error');
            }
        }

        async function handleWebSocketMessage(data) {
            if (data.type !== 'webrtc-signal') return;
            
            try {
                switch (data.signalType) {
                    case 'offer':
                        log('üì• –ü–æ–ª—É—á–µ–Ω offer');
                        await pc.setRemoteDescription(new RTCSessionDescription({
                            type: 'offer',
                            sdp: data.data.sdp
                        }));
                        
                        const answer = await pc.createAnswer();
                        await pc.setLocalDescription(answer);
                        
                        log('üì§ –û—Ç–ø—Ä–∞–≤–ª—è–µ–º answer');
                        ws.send(JSON.stringify({
                            type: 'webrtc-signal',
                            signalType: 'answer',
                            data: {
                                sdp: answer.sdp
                            }
                        }));
                        break;
                        
                    case 'ice-candidate':
                        log('üì• –ü–æ–ª—É—á–µ–Ω ICE candidate');
                        await pc.addIceCandidate(new RTCIceCandidate({
                            candidate: data.data.candidate,
                            sdpMLineIndex: data.data.sdpMLineIndex,
                            sdpMid: data.data.sdpMid
                        }));
                        break;
                        
                    default:
                        log(`ü§∑ –ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ç–∏–ø —Å–∏–≥–Ω–∞–ª–∞: ${data.signalType}`);
                }
            } catch (error) {
                log(`‚ùå –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å–∏–≥–Ω–∞–ª–∞: ${error.message}`, 'error');
            }
        }

        function startVideoStats() {
            if (statsInterval) clearInterval(statsInterval);
            
            statsInterval = setInterval(() => {
                if (pc && pc.connectionState === 'connected') {
                    pc.getStats().then(stats => {
                        stats.forEach(report => {
                            if (report.type === 'inbound-rtp' && report.mediaType === 'video') {
                                if (report.framesReceived !== undefined) {
                                    frameCount = report.framesReceived;
                                    updateStatus('framesCount', frameCount.toString(), frameCount > 0);
                                }
                            }
                        });
                    });
                }
            }, 1000);
        }

        function stopConnection() {
            log('üõë –û—Ç–∫–ª—é—á–∞–µ–º—Å—è...');
            
            if (statsInterval) {
                clearInterval(statsInterval);
                statsInterval = null;
            }
            
            if (registrationTimeout) {
                clearTimeout(registrationTimeout);
                registrationTimeout = null;
            }
            
            if (pc) {
                pc.close();
                pc = null;
            }
            
            if (ws) {
                ws.close();
                ws = null;
            }
            
            videoElement.srcObject = null;
            frameCount = 0;
            
            updateStatus('connectionStatus', '‚ùå –û—Ç–∫–ª—é—á–µ–Ω');
            updateStatus('iceStatus', '‚ùå –û—Ç–∫–ª—é—á–µ–Ω');
            updateStatus('videoStatus', '‚ùå –û—Ç–∫–ª—é—á–µ–Ω');
            updateStatus('framesCount', '0');
            
            connectBtn.disabled = false;
            disconnectBtn.disabled = true;
            
            log('‚úÖ –û—Ç–∫–ª—é—á–µ–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–æ');
        }

        // Auto-connect on page load (optional)
        // window.addEventListener('load', startConnection);
    </script>
</body>
</html> 